<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="Keywords" content="blog"/>
    <meta name="Description" content="blog"/>
    <title>Simple</title>
    <link rel="shortcut icon" href="/static/favicon.png"/>
    <link rel="stylesheet" type="text/css" href="/main.css" />
</head>
<body>
<div class="main">
    <div class="header">
    	<ul id="pages">
            <li><a href="/">home</a></li>
            <li><a href="/#/tags">tags</a></li>
            <li><a href="/#/archive">archive</a></li>
    	</ul>
    </div>
	<div class="wrap-header">
	<h1>
    <a href="/" id="title"></a>
	</h1>
	</div>
<div id="md" style="display: none;">
<!-- markdown -->
面向对象：★★★★★
特点
1：将复杂的事情简单化。
2：面向对象将以前的过程中的执行者，变成了指挥者。
3：面向对象这种思想是符合现在人们思考习惯的一种思想。

过程和对象在我们的程序中是如何体现的呢？过程其实就是函数；对象是将函数等一些内容进行了封装。

匿名对象使用场景：
1：当对方法只进行一次调用的时候，可以使用匿名对象。
2：当对象对成员进行多次调用时，不能使用匿名对象。必须给对象起名字。

在类中定义其实都称之为成员。成员有两种：
1：成员变量：其实对应的就是事物的属性。
2：成员函数：其实对应的就是事物的行为。

所以，其实定义类，就是在定义成员变量和成员函数。但是在定义前，必须先要对事物进行属性和行为的分析，才可以用代码来体现。

private int age;//私有的访问权限最低，只有在本类中的访问有效。
注意：私有仅仅是封装的一种体现形式而已。

私有的成员：其他类不能直接创建对象访问，所以只有通过本类对外提供具体的访问方式来完成对私有的访问，可以通过对外提供函数的形式对其进行访问。
好处：可以在函数中加入逻辑判断等操作，对数据进行判断等操作。

总结：开发时，记住，属性是用于存储数据的，直接被访问，容易出现安全隐患，所以，类中的属性通常被私有化，并对外提供公共的访问方法。
这个方法一般有两个，规范写法：对于属性 xxx，可以使用setXXX(),getXXX()对其进行操作。

类中怎么没有定义主函数呢？
注意：主函数的存在，仅为该类是否需要独立运行，如果不需要，主函数是不用定义的。
主函数的解释：保证所在类的独立运行，是程序的入口，被jvm调用。

成员变量和局部变量的区别：
1：成员变量直接定义在类中。
   局部变量定义在方法中，参数上，语句中。
2：成员变量在这个类中有效。
局部变量只在自己所属的大括号内有效，大括号结束，局部变量失去作用域。
3：成员变量存在于堆内存中，随着对象的产生而存在，消失而消失。
局部变量存在于栈内存中，随着所属区域的运行而存在，结束而释放。

构造函数：用于给对象进行初始化，是给与之对应的对象进行初始化，它具有针对性，函数中的一种。
特点：
1：该函数的名称和所在类的名称相同。
2：不需要定义返回值类型。
3：该函数没有具体的返回值。
记住：所有对象创建时，都需要初始化才可以使用。

注意事项：一个类在定义时，如果没有定义过构造函数，那么该类中会自动生成一个空参数的构造函数，为了方便该类创建对象，完成初始化。如果在类中自定义了构造函数，那么默认的构造函数就没有了。

一个类中，可以有多个构造函数，因为它们的函数名称都相同，所以只能通过参数列表来区分。所以，一个类中如果出现多个构造函数。它们的存在是以重载体现的。

构造函数和一般函数有什么区别呢？
1：两个函数定义格式不同。
2：构造函数是在对象创建时，就被调用，用于初始化，而且初始化动作只执行一次。
    一般函数，是对象创建后，需要调用才执行，可以被调用多次。
   
什么时候使用构造函数呢？
分析事物时，发现具体事物一出现，就具备了一些特征，那就将这些特征定义到构造函数内。

构造代码块和构造函数有什么区别？
构造代码块：是给所有的对象进行初始化，也就是说，所有的对象都会调用一个代码块。只要对象一建立。就会调用这个代码块。
构造函数：是给与之对应的对象进行初始化。它具有针对性。

Person p = new Person();
创建一个对象都在内存中做了什么事情？
1：先将硬盘上指定位置的Person.class文件加载进内存。
2：执行main方法时，在栈内存中开辟了main方法的空间(压栈-进栈)，然后在main方法的栈区分配了一个变量p。
3：在堆内存中开辟一个实体空间，分配了一个内存首地址值。new
4：在该实体空间中进行属性的空间分配，并进行了默认初始化。
5：对空间中的属性进行显示初始化。
6：进行实体的构造代码块初始化。
7：调用该实体对应的构造函数，进行构造函数初始化。（）
8：将首地址赋值给p ，p变量就引用了该实体。(指向了该对象)
--------------------------------------------------------------------------------------------
封 装（面向对象特征之一）：是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。
好处：将变化隔离；便于使用；提高重用性；安全性。
封装原则：将不需要对外提供的内容都隐藏起来，把属性都隐藏，提供公共方法对其访问。

this:代表对象。就是所在函数所属对象的引用。
this到底代表什么呢？哪个对象调用了this所在的函数，this就代表哪个对象，就是哪个对象的引用。
开发时，什么时候使用this呢？
在定义功能时，如果该功能内部使用到了调用该功能的对象，这时就用this来表示这个对象。

this 还可以用于构造函数间的调用。
调用格式：this(实际参数)；
this对象后面跟上 .  调用的是成员属性和成员方法(一般方法)；
this对象后面跟上 () 调用的是本类中的对应参数的构造函数。

注意：用this调用构造函数，必须定义在构造函数的第一行。因为构造函数是用于初始化的，所以初始化动作一定要执行。否则编译失败。

static：★★★ 关键字，是一个修饰符，用于修饰成员(成员变量和成员函数)。
特点：
1，想要实现对象中的共性数据的对象共享。可以将这个数据进行静态修饰。
2，被静态修饰的成员，可以直接被类名所调用。也就是说，静态的成员多了一种调用方式。类名.静态方式。
3，静态随着类的加载而加载。而且优先于对象存在。

弊端：
1，有些数据是对象特有的数据，是不可以被静态修饰的。因为那样的话，特有数据会变成对象的共享数据。这样对事物的描述就出了问题。所以，在定义静态时，必须要明确，这个数据是否是被对象所共享的。
2，静态方法只能访问静态成员，不可以访问非静态成员。
因为静态方法加载时，优先于对象存在，所以没有办法访问对象中的成员。
3，静态方法中不能使用this，super关键字。
因为this代表对象，而静态在时，有可能没有对象，所以this无法使用。
4，主函数是静态的。

什么时候定义静态成员呢？或者说：定义成员时，到底需不需要被静态修饰呢？
成员分两种：
1，成员变量。（数据共享时静态化）
该成员变量的数据是否是所有对象都一样：
如果是，那么该变量需要被静态修饰，因为是共享的数据。 
如果不是，那么就说这是对象的特有数据，要存储到对象中。 
2，成员函数。（方法中没有调用特有数据时就定义成静态）
	如果判断成员函数是否需要被静态修饰呢？
	只要参考，该函数内是否访问了对象中的特有数据：
	如果有访问特有数据，那方法不能被静态修饰。
	如果没有访问过特有数据，那么这个方法需要被静态修饰。

成员变量和静态变量的区别：
1，成员变量所属于对象。所以也称为实例变量。
静态变量所属于类。所以也称为类变量。
2，成员变量存在于堆内存中。
静态变量存在于方法区中。
3，成员变量随着对象创建而存在。随着对象被回收而消失。
静态变量随着类的加载而存在。随着类的消失而消失。
4，成员变量只能被对象所调用 。
静态变量可以被对象调用，也可以被类名调用。
所以，成员变量可以称为对象的特有数据，静态变量称为对象的共享数据。

静态的注意：静态的生命周期很长。
静态代码块：就是一个有静态关键字标示的一个代码块区域。定义在类中。
作用：可以完成类的初始化。静态代码块随着类的加载而执行，而且只执行一次（new 多个对象就只执行一次）。如果和主函数在同一类中，优先于主函数执行。

Public：访问权限最大。
static：不需要对象，直接类名即可。
void：主函数没有返回值。
Main：主函数特定的名称。
(String[] args)：主函数的参数，是一个字符串数组类型的参数，jvm调用main方法时，传递的实际参数是 new String[0]。

jvm默认传递的是长度为0的字符串数组，我们在运行该类时，也可以指定具体的参数进行传递。可以在控制台，运行该类时，在后面加入参数。参数之间通过空格隔开。jvm会自动将这些字符串参数作为args数组中的元素，进行存储。

静态代码块、构造代码块、构造函数同时存在时的执行顺序：静态代码块  构造代码块  构造函数；

生成Java帮助文档：命令格式：javadoc –d 文件夹名 –auther –version *.java
/**     //格式
*类描述
*@author 作者名
*@version 版本号
*/
/**
*方法描述
*@param  参数描述
*@return  返回值描述
*/
---------------------------------------------------------------------------------------------
设计模式：解决问题最行之有效的思想。是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。

java中有23种设计模式：
单例设计模式：★★★★★
解决的问题：保证一个类在内存中的对象唯一性。
比如：多程序读取一个配置文件时，建议配置文件封装成对象。会方便操作其中数据，又要保证多个程序读到的是同一个配置文件对象，就需要该配置文件对象在内存中是唯一的。

Runtime()方法就是单例设计模式进行设计的。

如何保证对象唯一性呢？
思想：
1，不让其他程序创建该类对象。
2，在本类中创建一个本类对象。
3，对外提供方法，让其他程序获取这个对象。

步骤：
1，因为创建对象都需要构造函数初始化，只要将本类中的构造函数私有化，其他程序就无法再创建该类对象；
2，就在类中创建一个本类的对象；
3，定义一个方法，返回该对象，让其他程序可以通过方法就得到本类对象。（作用：可控）

代码体现：
1，私有化构造函数；
2，创建私有并静态的本类对象；
3，定义公有并静态的方法，返回该对象。
---------------------------------------------
//饿汉式
class Single{
	private Single(){} //私有化构造函数。
private static Single s = new Single(); //创建私有并静态的本类对象。
	public static Single getInstance(){ //定义公有并静态的方法，返回该对象。
		return s;
	}
}
---------------------------------------------
//懒汉式:延迟加载方式。
class Single2{
	private Single2(){}
private static Single2 s = null;
	public static Single2 getInstance(){
		if(s==null)
			s = new Single2();
		return s;
	}
}
-------------------------------------------------------------------------------------------------
继 承（面向对象特征之一）
好处：
1：提高了代码的复用性。
2：让类与类之间产生了关系，提供了另一个特征多态的前提。

父类的由来：其实是由多个类不断向上抽取共性内容而来的。
java中对于继承，java只支持单继承。java虽然不直接支持多继承，但是保留了这种多继承机制，进行改良。

单继承：一个类只能有一个父类。
多继承：一个类可以有多个父类。

为什么不支持多继承呢？
因为当一个类同时继承两个父类时，两个父类中有相同的功能，那么子类对象调用该功能时，运行哪一个呢？因为父类中的方法中存在方法体。
但是java支持多重继承。A继承B  B继承C  C继承D。
多重继承的出现，就有了继承体系。体系中的顶层父类是通过不断向上抽取而来的。它里面定义的该体系最基本最共性内容的功能。
所以，一个体系要想被使用，直接查阅该系统中的父类的功能即可知道该体系的基本用法。那么想要使用一个体系时，需要建立对象。建议建立最子类对象，因为最子类不仅可以使用父类中的功能。还可以使用子类特有的一些功能。

简单说：对于一个继承体系的使用，查阅顶层父类中的内容，创建最底层子类的对象。 

子父类出现后，类中的成员都有了哪些特点：
1：成员变量。
	 当子父类中出现一样的属性时，子类类型的对象，调用该属性，值是子类的属性值。
	 如果想要调用父类中的属性值，需要使用一个关键字：super 
	 This：代表是本类类型的对象引用。
	 Super：代表是子类所属的父类中的内存空间引用。
	 注意：子父类中通常是不会出现同名成员变量的，因为父类中只要定义了，子类就不用在定义了，直接继承过来用就可以了。
2：成员函数。
当子父类中出现了一模一样的方法时，建立子类对象会运行子类中的方法。好像父类中的方法被覆盖掉一样。所以这种情况，是函数的另一个特性：覆盖(复写，重写)
什么时候使用覆盖呢？当一个类的功能内容需要修改时，可以通过覆盖来实现。
3：构造函数。
发现子类构造函数运行时，先运行了父类的构造函数。为什么呢?
原因：子类的所有构造函数中的第一行，其实都有一条隐身的语句super();
super(): 表示父类的构造函数，并会调用于参数相对应的父类中的构造函数。而super():是在调用父类中空参数的构造函数。
为什么子类对象初始化时，都需要调用父类中的函数？(为什么要在子类构造函数的第一行加入这个super()?)
因为子类继承父类，会继承到父类中的数据，所以必须要看父类是如何对自己的数据进行初始化的。所以子类在进行对象初始化时，先调用父类的构造函数，这就是子类的实例化过程。

注意：子类中所有的构造函数都会默认访问父类中的空参数的构造函数，因为每一个子类构造内第一行都有默认的语句super(); 
如果父类中没有空参数的构造函数，那么子类的构造函数内，必须通过super语句指定要访问的父类中的构造函数。
如果子类构造函数中用this来指定调用子类自己的构造函数，那么被调用的构造函数也一样会访问父类中的构造函数。

问题：super()和this()是否可以同时出现的构造函数中。
两个语句只能有一个定义在第一行，所以只能出现其中一个。

super()或者this():为什么一定要定义在第一行？
因为super()或者this()都是调用构造函数，构造函数用于初始化，所以初始化的动作要先完成。

继承的细节：
什么时候使用继承呢？
当类与类之间存在着所属关系时，才具备了继承的前提。a是b中的一种。a继承b。狼是犬科中的一种。
英文书中，所属关系：" is a "
注意：不要仅仅为了获取其他类中的已有成员进行继承。

所以判断所属关系，可以简单看，如果继承后，被继承的类中的功能，都可以被该子类所具备，那么继承成立。如果不是，不可以继承。

细节二：
在方法覆盖时，注意两点：
1：子类覆盖父类时，必须要保证，子类方法的权限必须大于等于父类方法权限可以实现继承。否则，编译失败。
2：覆盖时，要么都静态，要么都不静态。 (静态只能覆盖静态，或者被静态覆盖)

继承的一个弊端：打破了封装性。对于一些类，或者类中功能，是需要被继承，或者复写的。
这时如何解决问题呢？介绍一个关键字，final:最终。

final特点：
1：这个关键字是一个修饰符，可以修饰类，方法，变量。
2：被final修饰的类是一个最终类，不可以被继承。
3：被final修饰的方法是一个最终方法，不可以被覆盖。
4：被final修饰的变量是一个常量，只能赋值一次。

	其实这样的原因的就是给一些固定的数据起个阅读性较强的名称。
	不加final修饰不是也可以使用吗？那么这个值是一个变量，是可以更改的。加了final，程序更为严谨。常量名称定义时，有规范，所有字母都大写，如果由多个单词组成，中间用 _ 连接。

抽象类: abstract
抽象：不具体，看不明白。抽象类表象体现。
在不断抽取过程中，将共性内容中的方法声明抽取，但是方法不一样，没有抽取，这时抽取到的方法，并不具体，需要被指定关键字abstract所标示，声明为抽象方法。
抽象方法所在类一定要标示为抽象类，也就是说该类需要被abstract关键字所修饰。

抽象类的特点：
1：抽象方法只能定义在抽象类中，抽象类和抽象方法必须由abstract关键字修饰（可以描述类和方法，不可以描述变量）。
2：抽象方法只定义方法声明，并不定义方法实现。
3：抽象类不可以被创建对象(实例化)。
4：只有通过子类继承抽象类并覆盖了抽象类中的所有抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。

抽象类的细节：
1：抽象类中是否有构造函数？有，用于给子类对象进行初始化。
2：抽象类中是否可以定义非抽象方法？
	可以。其实，抽象类和一般类没有太大的区别，都是在描述事物，只不过抽象类在描述事物时，有些功能不具体。所以抽象类和一般类在定义上，都是需要定义属性和行为的。只不过，比一般类多了一个抽象函数。而且比一般类少了一个创建对象的部分。
3：抽象关键字abstract和哪些不可以共存？final ,	private , static 
4：抽象类中可不可以不定义抽象方法？可以。抽象方法目的仅仅为了不让该类创建对象。
-----------------------------------------------------------------------------------------------
模板方法设计模式：
解决的问题：当功能内部一部分实现是确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。     
abstract class GetTime{
	public final void getTime(){ //此功能如果不需要复写，可加final限定
		long start = System.currentTimeMillis();
		code(); //不确定的功能部分，提取出来，通过抽象方法实现
		long end = System.currentTimeMillis();
		System.out.println("毫秒是："+(end-start));
	}
	public abstract void code(); //抽象不确定的功能，让子类复写实现
}
class SubDemo extends GetTime{
	public void code(){ //子类复写功能方法
		for(int y=0; y<1000; y++){
			System.out.println("y");
		}
	}
}
---------------------------------------------------------------------------------------------

接 口：★★★★★
1：是用关键字interface定义的。
2：接口中包含的成员，最常见的有全局常量、抽象方法。
注意：接口中的成员都有固定的修饰符。
	成员变量：public static final 
	成员方法：public abstract 
interface Inter{
	public static final int x = 3;
	public abstract void show();
}
3：接口中有抽象方法，说明接口不可以实例化。接口的子类必须实现了接口中所有的抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。
4：类与类之间存在着继承关系，类与接口中间存在的是实现关系。
	继承用extends  ；实现用implements ；
5：接口和类不一样的地方，就是，接口可以被多实现，这就是多继承改良后的结果。java将多继承机制通过多实现来体现。 
6：一个类在继承另一个类的同时，还可以实现多个接口。所以接口的出现避免了单继承的局限性。还可以将类进行功能的扩展。
7：其实java中是有多继承的。接口与接口之间存在着继承关系，接口可以多继承接口。

接口都用于设计上，设计上的特点：（可以理解主板上提供的接口）
1：接口是对外提供的规则。
2：接口是功能的扩展。
3：接口的出现降低了耦合性。

抽象类与接口：
抽象类：一般用于描述一个体系单元，将一组共性内容进行抽取，特点：可以在类中定义抽象内容让子类实现，可以定义非抽象内容让子类直接使用。它里面定义的都是一些体系中的基本内容。
接口：一般用于定义对象的扩展功能，是在继承之外还需这个对象具备的一些功能。

抽象类和接口的共性：都是不断向上抽取的结果。

抽象类和接口的区别：
1：抽象类只能被继承，而且只能单继承。
接口需要被实现，而且可以多实现。 
2：抽象类中可以定义非抽象方法，子类可以直接继承使用。
接口中都有抽象方法，需要子类去实现。
3：抽象类使用的是  is a 关系。
接口使用的 like a 关系。 
4：抽象类的成员修饰符可以自定义。
接口中的成员修饰符是固定的。全都是public的。

在开发之前，先定义规则，A和B分别开发，A负责实现这个规则，B负责使用这个规则。至于A是如何对规则具体实现的，B是不需要知道的。这样这个接口的出现就降低了A和B直接耦合性。 

------------------------------------------------------------------------------------------------
多 态★★★★★（面向对象特征之一）：函数本身就具备多态性，某一种事物有不同的具体的体现。

体现：父类引用或者接口的引用指向了自己的子类对象。//Animal a = new Cat();
多态的好处：提高了程序的扩展性。
多态的弊端：当父类引用指向子类对象时，虽然提高了扩展性，但是只能访问父类中具备的方法，不可以访问子类中特有的方法。(前期不能使用后期产生的功能，即访问的局限性)
多态的前提：
	1：必须要有关系，比如继承、或者实现。
	2：通常会有覆盖操作。

多态的出现思想上也做着变化：以前是创建对象并指挥对象做事情。有了多态以后，我们可以找到对象的共性类型，直接操作共性类型做事情即可，这样可以指挥一批对象做事情，即通过操作父类或接口实现。
--------------------------------------------------------------
class 毕姥爷{
	void 讲课(){
		System.out.println("企业管理");
	}
	void 钓鱼(){
		System.out.println("钓鱼");
	}
}
class 毕老师 extends 毕姥爷{
	void 讲课(){
		System.out.println("JAVA");
	}
	void 看电影(){
		System.out.println("看电影");
	}
}
class {
	public static void main(String[] args) {
		毕姥爷 x = new 毕老师(); //毕老师对象被提升为了毕姥爷类型。 
//		x.讲课();
//		x.看电影();  //错误.
		毕老师 y = (毕老师)x; //将毕姥爷类型强制转换成毕老师类型。 
		y.看电影();//在多态中，自始自终都是子类对象在做着类型的变化。
	}
}
---------------------------------------------------------------
如果想用子类对象的特有方法，如何判断对象是哪个具体的子类类型呢？
可以可以通过一个关键字 instanceof ;//判断对象是否实现了指定的接口或继承了指定的类

格式：<对象 instanceof 类型> ，判断一个对象是否所属于指定的类型。
Student instanceof Person = true;//student继承了person类

多态在子父类中的成员上的体现的特点：
1，成员变量：在多态中，子父类成员变量同名。
	在编译时期：参考的是引用型变量所属的类中是否有调用的成员。（编译时不产生对象，只检查语法错误）
	运行时期：也是参考引用型变量所属的类中是否有调用的成员。
	简单一句话：无论编译和运行，成员变量参考的都是引用变量所属的类中的成员变量。
	再说的更容易记忆一些：成员变量 --- 编译运行都看 = 左边。
2，成员函数。
	编译时期：参考引用型变量所属的类中是否有调用的方法。
	运行事情：参考的是对象所属的类中是否有调用的方法。
	为什么是这样的呢？因为在子父类中，对于一模一样的成员函数，有一个特性：覆盖。
	简单一句：成员函数，编译看引用型变量所属的类，运行看对象所属的类。
	更简单：成员函数 --- 编译看 = 左边，运行看 = 右边。
3，静态函数。 
	编译时期：参考的是引用型变量所属的类中是否有调用的成员。
	运行时期：也是参考引用型变量所属的类中是否有调用的成员。
	为什么是这样的呢？因为静态方法，其实不所属于对象，而是所属于该方法所在的类。
	调用静态的方法引用是哪个类的引用调用的就是哪个类中的静态方法。
	简单说：静态函数 --- 编译运行都看 = 左边。
-----------------------------------------------------------------------------------------------
------java.lang.Object
Object：所有类的直接或者间接父类，Java认为所有的对象都具备一些基本的共性内容，这些内容可以不断的向上抽取，最终就抽取到了一个最顶层的类中的，该类中定义的就是所有对象都具备的功能。

具体方法：
1，boolean equals(Object obj)：用于比较两个对象是否相等，其实内部比较的就是两个对象地址。
而根据对象的属性不同，判断对象是否相同的具体内容也不一样。所以在定义类时，一般都会复写equals方法，建立本类特有的判断对象是否相同的依据。
	public boolean equals(Object obj){
		if(!(obj instanceof Person))
			return false;
		Person p = (Person)obj;
		return this.age == p.age;
	}
2，String toString()：将对象变成字符串；默认返回的格式：类名@哈希值 = getClass().getName() + '@' + Integer.toHexString(hashCode())
	为了对象对应的字符串内容有意义，可以通过复写，建立该类对象自己特有的字符串表现形式。 
	public String toString(){
		return "person : "+age;
	}
3，Class getClass()：获取任意对象运行时的所属字节码文件对象。
4，int hashCode()：返回该对象的哈希码值。支持此方法是为了提高哈希表的性能。

通常equals，toString，hashCode，在应用中都会被复写，建立具体对象的特有的内容。
------------------------------------------------------------------------------------------------
内部类：如果A类需要直接访问B类中的成员，而B类又需要建立A类的对象。这时,为了方便设计和访问，直接将A类定义在B类中。就可以了。A类就称为内部类。内部类可以直接访问外部类中的成员。而外部类想要访问内部类，必须要建立内部类的对象。
-----------------------------------------------------
class Outer{
	int num = 4;	
	class  Inner {
		void show(){
			System.out.println("inner show run "+num);			
		}
	}
	public void method(){
		Inner in = new Inner();//创建内部类的对象。
		in.show();//调用内部类的方法。 
	}
}
-------------------------------------------------------
当内部类定义在外部类中的成员位置上，可以使用一些成员修饰符修饰 private、static。
1：默认修饰符。
直接访问内部类格式：外部类名.内部类名 变量名 =  外部类对象.内部类对象;
Outer.Inner in = new Outer.new Inner();//这种形式很少用。
	但是这种应用不多见，因为内部类之所以定义在内部就是为了封装。想要获取内部类对象通常都通过外部类的方法来获取。这样可以对内部类对象进行控制。
2：私有修饰符。
	通常内部类被封装，都会被私有化，因为封装性不让其他程序直接访问。 
3：静态修饰符。
	如果内部类被静态修饰，相当于外部类，会出现访问局限性，只能访问外部类中的静态成员。
	注意；如果内部类中定义了静态成员，那么该内部类必须是静态的。

内部类编译后的文件名为：“外部类名$内部类名.java”；

为什么内部类可以直接访问外部类中的成员呢？
那是因为内部中都持有一个外部类的引用。这个引用是 外部类名.this 
内部类可以定义在外部类中的成员位置上，也可以定义在外部类中的局部位置上。
当内部类被定义在局部位置上，只能访问局部中被final修饰的局部变量。

匿名内部类：没有名字的内部类。就是内部类的简化形式。一般只用一次就可以用这种形式。匿名内部类其实就是一个匿名子类对象。想要定义匿名内部类：需要前提，内部类必须继承一个类或者实现接口。

匿名内部类的格式：new 父类名&接口名(){ 定义子类成员或者覆盖父类方法 }.方法。

匿名内部类的使用场景：
当函数的参数是接口类型引用时，如果接口中的方法不超过3个。可以通过匿名内部类来完成参数的传递。
其实就是在创建匿名内部类时，该类中的封装的方法不要过多，最好两个或者两个以内。
--------------------------------------------------------
//面试
		//1
		new Object(){
			void show(){
				System.out.println("show run");				
			}
		}.show();
		//2
		Object obj = new Object(){
			void show(){
				System.out.println("show run");
			}
		};
		obj.show();
		
		1和2的写法正确吗？有区别吗？说出原因。
		写法是正确，1和2都是在通过匿名内部类建立一个Object类的子类对象。
		区别：
		第一个可是编译通过，并运行。
		第二个编译失败，因为匿名内部类是一个子类对象，当用Object的obj引用指向时，就被提升为了
		Object类型，而编译时检查Object类中是否有show方法，所以编译失败。
-------------------------------------------------------
class InnerClassDemo6 {
	+（static）class Inner{
		void show(){}
	}
	public void method(){
		this.new Inner().show();//可以
	}
	public static void main(String[] args) {//static不允许this
		This.new Inner().show();//错误，Inner类需要定义成static
	}
}
------------------------------------------------------
interface Inter{
	void show();
}
class Outer{//通过匿名内部类补足Outer类中的代码。
	public static Inter method(){
		return new Inter(){
			public void show(){}
		};
	}
}
class InnerClassDemo7 {
	public static void main(String[] args) {
		Outer.method().show();
	/*
		Outer.method():意思是：Outer中有一个名称为method的方法，而且这个方法是静态的。
		Outer.method().show():当Outer类调用静态的method方法运算结束后的结果又调用了show方法，意味着：method()方法运算完一个是对象，而且这个对象是Inter类型的。
	*/
		function (new Inter(){
			public void show(){}
		}); //匿名内部类作为方法的参数进行传递。
	}
	public static void function(Inter in){
		in.show();
	}
}
包：定义包用package关键字。
1：对类文件进行分类管理。
2：给类文件提供多层名称空间。

如果生成的包不在当前目录下，需要最好执行classpath，将包所在父目录定义到classpath变量中即可。
一般在定义包名时，因为包的出现是为了区分重名的类。所以包名要尽量唯一。怎么保证唯一性呢？可以使用url域名来进行包名称的定义。
package pack;//定义了一个包，名称为pack。 注意：包名的写法规范：所有字母都小写。
//package cn.itcast.pack.demo;

类的全名称是 包名.类名
    编译命令：javac –d 位置（.当前路径） java源文件 （就可以自动生成包）

包是一种封装形式，用于封装类，想要被包以外的程序访问，该类必须public；
类中的成员，如果被包以外访问，也必须public；

包与包之间访问可以使用的权限有两种：
1：public 
2：protected：只能是不同包中的子类可以使用的权限。

总结java中的四种权限：
    范围       public		protected		default		private 
同一个类中       ok				ok				ok			ok
同一包中		 ok				ok				ok		
子类			 ok			 
不同包中         ok


<!-- markdown end -->
</div>
<div class="entry" id="main">
<!-- content -->
<p>面向对象：★★★★★
特点
1：将复杂的事情简单化。
2：面向对象将以前的过程中的执行者，变成了指挥者。
3：面向对象这种思想是符合现在人们思考习惯的一种思想。</p>

<p>过程和对象在我们的程序中是如何体现的呢？过程其实就是函数；对象是将函数等一些内容进行了封装。</p>

<p>匿名对象使用场景：
1：当对方法只进行一次调用的时候，可以使用匿名对象。
2：当对象对成员进行多次调用时，不能使用匿名对象。必须给对象起名字。</p>

<p>在类中定义其实都称之为成员。成员有两种：
1：成员变量：其实对应的就是事物的属性。
2：成员函数：其实对应的就是事物的行为。</p>

<p>所以，其实定义类，就是在定义成员变量和成员函数。但是在定义前，必须先要对事物进行属性和行为的分析，才可以用代码来体现。</p>

<p>private int age;//私有的访问权限最低，只有在本类中的访问有效。
注意：私有仅仅是封装的一种体现形式而已。</p>

<p>私有的成员：其他类不能直接创建对象访问，所以只有通过本类对外提供具体的访问方式来完成对私有的访问，可以通过对外提供函数的形式对其进行访问。
好处：可以在函数中加入逻辑判断等操作，对数据进行判断等操作。</p>

<p>总结：开发时，记住，属性是用于存储数据的，直接被访问，容易出现安全隐患，所以，类中的属性通常被私有化，并对外提供公共的访问方法。
这个方法一般有两个，规范写法：对于属性 xxx，可以使用setXXX(),getXXX()对其进行操作。</p>

<p>类中怎么没有定义主函数呢？
注意：主函数的存在，仅为该类是否需要独立运行，如果不需要，主函数是不用定义的。
主函数的解释：保证所在类的独立运行，是程序的入口，被jvm调用。</p>

<p>成员变量和局部变量的区别：
1：成员变量直接定义在类中。
   局部变量定义在方法中，参数上，语句中。
2：成员变量在这个类中有效。
局部变量只在自己所属的大括号内有效，大括号结束，局部变量失去作用域。
3：成员变量存在于堆内存中，随着对象的产生而存在，消失而消失。
局部变量存在于栈内存中，随着所属区域的运行而存在，结束而释放。</p>

<p>构造函数：用于给对象进行初始化，是给与之对应的对象进行初始化，它具有针对性，函数中的一种。
特点：
1：该函数的名称和所在类的名称相同。
2：不需要定义返回值类型。
3：该函数没有具体的返回值。
记住：所有对象创建时，都需要初始化才可以使用。</p>

<p>注意事项：一个类在定义时，如果没有定义过构造函数，那么该类中会自动生成一个空参数的构造函数，为了方便该类创建对象，完成初始化。如果在类中自定义了构造函数，那么默认的构造函数就没有了。</p>

<p>一个类中，可以有多个构造函数，因为它们的函数名称都相同，所以只能通过参数列表来区分。所以，一个类中如果出现多个构造函数。它们的存在是以重载体现的。</p>

<p>构造函数和一般函数有什么区别呢？
1：两个函数定义格式不同。
2：构造函数是在对象创建时，就被调用，用于初始化，而且初始化动作只执行一次。
    一般函数，是对象创建后，需要调用才执行，可以被调用多次。</p>

<p>什么时候使用构造函数呢？
分析事物时，发现具体事物一出现，就具备了一些特征，那就将这些特征定义到构造函数内。</p>

<p>构造代码块和构造函数有什么区别？
构造代码块：是给所有的对象进行初始化，也就是说，所有的对象都会调用一个代码块。只要对象一建立。就会调用这个代码块。
构造函数：是给与之对应的对象进行初始化。它具有针对性。</p>

<p>Person p = new Person();
创建一个对象都在内存中做了什么事情？
1：先将硬盘上指定位置的Person.class文件加载进内存。
2：执行main方法时，在栈内存中开辟了main方法的空间(压栈-进栈)，然后在main方法的栈区分配了一个变量p。
3：在堆内存中开辟一个实体空间，分配了一个内存首地址值。new
4：在该实体空间中进行属性的空间分配，并进行了默认初始化。
5：对空间中的属性进行显示初始化。
6：进行实体的构造代码块初始化。
7：调用该实体对应的构造函数，进行构造函数初始化。（）</p>

<h2 id="8pp">8：将首地址赋值给p ，p变量就引用了该实体。(指向了该对象)</h2>

<p>封 装（面向对象特征之一）：是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。
好处：将变化隔离；便于使用；提高重用性；安全性。
封装原则：将不需要对外提供的内容都隐藏起来，把属性都隐藏，提供公共方法对其访问。</p>

<p>this:代表对象。就是所在函数所属对象的引用。
this到底代表什么呢？哪个对象调用了this所在的函数，this就代表哪个对象，就是哪个对象的引用。
开发时，什么时候使用this呢？
在定义功能时，如果该功能内部使用到了调用该功能的对象，这时就用this来表示这个对象。</p>

<p>this 还可以用于构造函数间的调用。
调用格式：this(实际参数)；
this对象后面跟上 .  调用的是成员属性和成员方法(一般方法)；
this对象后面跟上 () 调用的是本类中的对应参数的构造函数。</p>

<p>注意：用this调用构造函数，必须定义在构造函数的第一行。因为构造函数是用于初始化的，所以初始化动作一定要执行。否则编译失败。</p>

<p>static：★★★ 关键字，是一个修饰符，用于修饰成员(成员变量和成员函数)。
特点：
1，想要实现对象中的共性数据的对象共享。可以将这个数据进行静态修饰。
2，被静态修饰的成员，可以直接被类名所调用。也就是说，静态的成员多了一种调用方式。类名.静态方式。
3，静态随着类的加载而加载。而且优先于对象存在。</p>

<p>弊端：
1，有些数据是对象特有的数据，是不可以被静态修饰的。因为那样的话，特有数据会变成对象的共享数据。这样对事物的描述就出了问题。所以，在定义静态时，必须要明确，这个数据是否是被对象所共享的。
2，静态方法只能访问静态成员，不可以访问非静态成员。
因为静态方法加载时，优先于对象存在，所以没有办法访问对象中的成员。
3，静态方法中不能使用this，super关键字。
因为this代表对象，而静态在时，有可能没有对象，所以this无法使用。
4，主函数是静态的。</p>

<p>什么时候定义静态成员呢？或者说：定义成员时，到底需不需要被静态修饰呢？
成员分两种：
1，成员变量。（数据共享时静态化）
该成员变量的数据是否是所有对象都一样：
如果是，那么该变量需要被静态修饰，因为是共享的数据。 
如果不是，那么就说这是对象的特有数据，要存储到对象中。 
2，成员函数。（方法中没有调用特有数据时就定义成静态）
    如果判断成员函数是否需要被静态修饰呢？
    只要参考，该函数内是否访问了对象中的特有数据：
    如果有访问特有数据，那方法不能被静态修饰。
    如果没有访问过特有数据，那么这个方法需要被静态修饰。</p>

<p>成员变量和静态变量的区别：
1，成员变量所属于对象。所以也称为实例变量。
静态变量所属于类。所以也称为类变量。
2，成员变量存在于堆内存中。
静态变量存在于方法区中。
3，成员变量随着对象创建而存在。随着对象被回收而消失。
静态变量随着类的加载而存在。随着类的消失而消失。
4，成员变量只能被对象所调用 。
静态变量可以被对象调用，也可以被类名调用。
所以，成员变量可以称为对象的特有数据，静态变量称为对象的共享数据。</p>

<p>静态的注意：静态的生命周期很长。
静态代码块：就是一个有静态关键字标示的一个代码块区域。定义在类中。
作用：可以完成类的初始化。静态代码块随着类的加载而执行，而且只执行一次（new 多个对象就只执行一次）。如果和主函数在同一类中，优先于主函数执行。</p>

<p>Public：访问权限最大。
static：不需要对象，直接类名即可。
void：主函数没有返回值。
Main：主函数特定的名称。
(String[] args)：主函数的参数，是一个字符串数组类型的参数，jvm调用main方法时，传递的实际参数是 new String[0]。</p>

<p>jvm默认传递的是长度为0的字符串数组，我们在运行该类时，也可以指定具体的参数进行传递。可以在控制台，运行该类时，在后面加入参数。参数之间通过空格隔开。jvm会自动将这些字符串参数作为args数组中的元素，进行存储。</p>

<p>静态代码块、构造代码块、构造函数同时存在时的执行顺序：静态代码块  构造代码块  构造函数；</p>

<p>生成Java帮助文档：命令格式：javadoc –d 文件夹名 –auther –version <em>.java
/</em>*     //格式
<em>类描述
*@author 作者名
*@version 版本号
*/
/</em>*
*方法描述
*@param  参数描述
*@return  返回值描述</p>

<h2 id="">*/</h2>

<p>设计模式：解决问题最行之有效的思想。是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</p>

<p>java中有23种设计模式：
单例设计模式：★★★★★
解决的问题：保证一个类在内存中的对象唯一性。
比如：多程序读取一个配置文件时，建议配置文件封装成对象。会方便操作其中数据，又要保证多个程序读到的是同一个配置文件对象，就需要该配置文件对象在内存中是唯一的。</p>

<p>Runtime()方法就是单例设计模式进行设计的。</p>

<p>如何保证对象唯一性呢？
思想：
1，不让其他程序创建该类对象。
2，在本类中创建一个本类对象。
3，对外提供方法，让其他程序获取这个对象。</p>

<p>步骤：
1，因为创建对象都需要构造函数初始化，只要将本类中的构造函数私有化，其他程序就无法再创建该类对象；
2，就在类中创建一个本类的对象；
3，定义一个方法，返回该对象，让其他程序可以通过方法就得到本类对象。（作用：可控）</p>

<p>代码体现：
1，私有化构造函数；
2，创建私有并静态的本类对象；</p>

<h2 id="3">3，定义公有并静态的方法，返回该对象。</h2>

<p>//饿汉式
class Single{
    private Single(){} //私有化构造函数。
private static Single s = new Single(); //创建私有并静态的本类对象。
    public static Single getInstance(){ //定义公有并静态的方法，返回该对象。
        return s;
    }</p>

<h2 id="">}</h2>

<p>//懒汉式:延迟加载方式。
class Single2{
    private Single2(){}
private static Single2 s = null;
    public static Single2 getInstance(){
        if(s==null)
            s = new Single2();
        return s;
    }</p>

<h2 id="">}</h2>

<p>继 承（面向对象特征之一）
好处：
1：提高了代码的复用性。
2：让类与类之间产生了关系，提供了另一个特征多态的前提。</p>

<p>父类的由来：其实是由多个类不断向上抽取共性内容而来的。
java中对于继承，java只支持单继承。java虽然不直接支持多继承，但是保留了这种多继承机制，进行改良。</p>

<p>单继承：一个类只能有一个父类。
多继承：一个类可以有多个父类。</p>

<p>为什么不支持多继承呢？
因为当一个类同时继承两个父类时，两个父类中有相同的功能，那么子类对象调用该功能时，运行哪一个呢？因为父类中的方法中存在方法体。
但是java支持多重继承。A继承B  B继承C  C继承D。
多重继承的出现，就有了继承体系。体系中的顶层父类是通过不断向上抽取而来的。它里面定义的该体系最基本最共性内容的功能。
所以，一个体系要想被使用，直接查阅该系统中的父类的功能即可知道该体系的基本用法。那么想要使用一个体系时，需要建立对象。建议建立最子类对象，因为最子类不仅可以使用父类中的功能。还可以使用子类特有的一些功能。</p>

<p>简单说：对于一个继承体系的使用，查阅顶层父类中的内容，创建最底层子类的对象。 </p>

<p>子父类出现后，类中的成员都有了哪些特点：
1：成员变量。
     当子父类中出现一样的属性时，子类类型的对象，调用该属性，值是子类的属性值。
     如果想要调用父类中的属性值，需要使用一个关键字：super 
     This：代表是本类类型的对象引用。
     Super：代表是子类所属的父类中的内存空间引用。
     注意：子父类中通常是不会出现同名成员变量的，因为父类中只要定义了，子类就不用在定义了，直接继承过来用就可以了。
2：成员函数。
当子父类中出现了一模一样的方法时，建立子类对象会运行子类中的方法。好像父类中的方法被覆盖掉一样。所以这种情况，是函数的另一个特性：覆盖(复写，重写)
什么时候使用覆盖呢？当一个类的功能内容需要修改时，可以通过覆盖来实现。
3：构造函数。
发现子类构造函数运行时，先运行了父类的构造函数。为什么呢?
原因：子类的所有构造函数中的第一行，其实都有一条隐身的语句super();
super(): 表示父类的构造函数，并会调用于参数相对应的父类中的构造函数。而super():是在调用父类中空参数的构造函数。
为什么子类对象初始化时，都需要调用父类中的函数？(为什么要在子类构造函数的第一行加入这个super()?)
因为子类继承父类，会继承到父类中的数据，所以必须要看父类是如何对自己的数据进行初始化的。所以子类在进行对象初始化时，先调用父类的构造函数，这就是子类的实例化过程。</p>

<p>注意：子类中所有的构造函数都会默认访问父类中的空参数的构造函数，因为每一个子类构造内第一行都有默认的语句super(); 
如果父类中没有空参数的构造函数，那么子类的构造函数内，必须通过super语句指定要访问的父类中的构造函数。
如果子类构造函数中用this来指定调用子类自己的构造函数，那么被调用的构造函数也一样会访问父类中的构造函数。</p>

<p>问题：super()和this()是否可以同时出现的构造函数中。
两个语句只能有一个定义在第一行，所以只能出现其中一个。</p>

<p>super()或者this():为什么一定要定义在第一行？
因为super()或者this()都是调用构造函数，构造函数用于初始化，所以初始化的动作要先完成。</p>

<p>继承的细节：
什么时候使用继承呢？
当类与类之间存在着所属关系时，才具备了继承的前提。a是b中的一种。a继承b。狼是犬科中的一种。
英文书中，所属关系：" is a "
注意：不要仅仅为了获取其他类中的已有成员进行继承。</p>

<p>所以判断所属关系，可以简单看，如果继承后，被继承的类中的功能，都可以被该子类所具备，那么继承成立。如果不是，不可以继承。</p>

<p>细节二：
在方法覆盖时，注意两点：
1：子类覆盖父类时，必须要保证，子类方法的权限必须大于等于父类方法权限可以实现继承。否则，编译失败。
2：覆盖时，要么都静态，要么都不静态。 (静态只能覆盖静态，或者被静态覆盖)</p>

<p>继承的一个弊端：打破了封装性。对于一些类，或者类中功能，是需要被继承，或者复写的。
这时如何解决问题呢？介绍一个关键字，final:最终。</p>

<p>final特点：
1：这个关键字是一个修饰符，可以修饰类，方法，变量。
2：被final修饰的类是一个最终类，不可以被继承。
3：被final修饰的方法是一个最终方法，不可以被覆盖。
4：被final修饰的变量是一个常量，只能赋值一次。</p>

<pre><code>其实这样的原因的就是给一些固定的数据起个阅读性较强的名称。
不加final修饰不是也可以使用吗？那么这个值是一个变量，是可以更改的。加了final，程序更为严谨。常量名称定义时，有规范，所有字母都大写，如果由多个单词组成，中间用 _ 连接。
</code></pre>

<p>抽象类: abstract
抽象：不具体，看不明白。抽象类表象体现。
在不断抽取过程中，将共性内容中的方法声明抽取，但是方法不一样，没有抽取，这时抽取到的方法，并不具体，需要被指定关键字abstract所标示，声明为抽象方法。
抽象方法所在类一定要标示为抽象类，也就是说该类需要被abstract关键字所修饰。</p>

<p>抽象类的特点：
1：抽象方法只能定义在抽象类中，抽象类和抽象方法必须由abstract关键字修饰（可以描述类和方法，不可以描述变量）。
2：抽象方法只定义方法声明，并不定义方法实现。
3：抽象类不可以被创建对象(实例化)。
4：只有通过子类继承抽象类并覆盖了抽象类中的所有抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。</p>

<p>抽象类的细节：
1：抽象类中是否有构造函数？有，用于给子类对象进行初始化。
2：抽象类中是否可以定义非抽象方法？
    可以。其实，抽象类和一般类没有太大的区别，都是在描述事物，只不过抽象类在描述事物时，有些功能不具体。所以抽象类和一般类在定义上，都是需要定义属性和行为的。只不过，比一般类多了一个抽象函数。而且比一般类少了一个创建对象的部分。
3：抽象关键字abstract和哪些不可以共存？final ,    private , static </p>

<h2 id="4">4：抽象类中可不可以不定义抽象方法？可以。抽象方法目的仅仅为了不让该类创建对象。</h2>

<p>模板方法设计模式：
解决的问题：当功能内部一部分实现是确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。 <br>
abstract class GetTime{
    public final void getTime(){ //此功能如果不需要复写，可加final限定
        long start = System.currentTimeMillis();
        code(); //不确定的功能部分，提取出来，通过抽象方法实现
        long end = System.currentTimeMillis();
        System.out.println("毫秒是："+(end-start));
    }
    public abstract void code(); //抽象不确定的功能，让子类复写实现
}
class SubDemo extends GetTime{
    public void code(){ //子类复写功能方法
        for(int y=0; y&lt;1000; y++){
            System.out.println("y");
        }
    }</p>

<h2 id="">}</h2>

<p>接 口：★★★★★
1：是用关键字interface定义的。
2：接口中包含的成员，最常见的有全局常量、抽象方法。
注意：接口中的成员都有固定的修饰符。
    成员变量：public static final 
    成员方法：public abstract 
interface Inter{
    public static final int x = 3;
    public abstract void show();
}
3：接口中有抽象方法，说明接口不可以实例化。接口的子类必须实现了接口中所有的抽象方法后，该子类才可以实例化。否则，该子类还是一个抽象类。
4：类与类之间存在着继承关系，类与接口中间存在的是实现关系。
    继承用extends  ；实现用implements ；
5：接口和类不一样的地方，就是，接口可以被多实现，这就是多继承改良后的结果。java将多继承机制通过多实现来体现。 
6：一个类在继承另一个类的同时，还可以实现多个接口。所以接口的出现避免了单继承的局限性。还可以将类进行功能的扩展。
7：其实java中是有多继承的。接口与接口之间存在着继承关系，接口可以多继承接口。</p>

<p>接口都用于设计上，设计上的特点：（可以理解主板上提供的接口）
1：接口是对外提供的规则。
2：接口是功能的扩展。
3：接口的出现降低了耦合性。</p>

<p>抽象类与接口：
抽象类：一般用于描述一个体系单元，将一组共性内容进行抽取，特点：可以在类中定义抽象内容让子类实现，可以定义非抽象内容让子类直接使用。它里面定义的都是一些体系中的基本内容。
接口：一般用于定义对象的扩展功能，是在继承之外还需这个对象具备的一些功能。</p>

<p>抽象类和接口的共性：都是不断向上抽取的结果。</p>

<p>抽象类和接口的区别：
1：抽象类只能被继承，而且只能单继承。
接口需要被实现，而且可以多实现。 
2：抽象类中可以定义非抽象方法，子类可以直接继承使用。
接口中都有抽象方法，需要子类去实现。
3：抽象类使用的是  is a 关系。
接口使用的 like a 关系。 
4：抽象类的成员修饰符可以自定义。
接口中的成员修饰符是固定的。全都是public的。</p>

<p>在开发之前，先定义规则，A和B分别开发，A负责实现这个规则，B负责使用这个规则。至于A是如何对规则具体实现的，B是不需要知道的。这样这个接口的出现就降低了A和B直接耦合性。 </p>

<hr>

<p>多 态★★★★★（面向对象特征之一）：函数本身就具备多态性，某一种事物有不同的具体的体现。</p>

<p>体现：父类引用或者接口的引用指向了自己的子类对象。//Animal a = new Cat();
多态的好处：提高了程序的扩展性。
多态的弊端：当父类引用指向子类对象时，虽然提高了扩展性，但是只能访问父类中具备的方法，不可以访问子类中特有的方法。(前期不能使用后期产生的功能，即访问的局限性)
多态的前提：
    1：必须要有关系，比如继承、或者实现。
    2：通常会有覆盖操作。</p>

<h2 id="">多态的出现思想上也做着变化：以前是创建对象并指挥对象做事情。有了多态以后，我们可以找到对象的共性类型，直接操作共性类型做事情即可，这样可以指挥一批对象做事情，即通过操作父类或接口实现。</h2>

<p>class 毕姥爷{
    void 讲课(){
        System.out.println("企业管理");
    }
    void 钓鱼(){
        System.out.println("钓鱼");
    }
}
class 毕老师 extends 毕姥爷{
    void 讲课(){
        System.out.println("JAVA");
    }
    void 看电影(){
        System.out.println("看电影");
    }
}
class {
    public static void main(String[] args) {
        毕姥爷 x = new 毕老师(); //毕老师对象被提升为了毕姥爷类型。 
//        x.讲课();
//        x.看电影();  //错误.
        毕老师 y = (毕老师)x; //将毕姥爷类型强制转换成毕老师类型。 
        y.看电影();//在多态中，自始自终都是子类对象在做着类型的变化。
    }</p>

<h2 id="">}</h2>

<p>如果想用子类对象的特有方法，如何判断对象是哪个具体的子类类型呢？
可以可以通过一个关键字 instanceof ;//判断对象是否实现了指定的接口或继承了指定的类</p>

<p>格式：&lt;对象 instanceof 类型&gt; ，判断一个对象是否所属于指定的类型。
Student instanceof Person = true;//student继承了person类</p>

<p>多态在子父类中的成员上的体现的特点：
1，成员变量：在多态中，子父类成员变量同名。
    在编译时期：参考的是引用型变量所属的类中是否有调用的成员。（编译时不产生对象，只检查语法错误）
    运行时期：也是参考引用型变量所属的类中是否有调用的成员。
    简单一句话：无论编译和运行，成员变量参考的都是引用变量所属的类中的成员变量。
    再说的更容易记忆一些：成员变量 --- 编译运行都看 = 左边。
2，成员函数。
    编译时期：参考引用型变量所属的类中是否有调用的方法。
    运行事情：参考的是对象所属的类中是否有调用的方法。
    为什么是这样的呢？因为在子父类中，对于一模一样的成员函数，有一个特性：覆盖。
    简单一句：成员函数，编译看引用型变量所属的类，运行看对象所属的类。
    更简单：成员函数 --- 编译看 = 左边，运行看 = 右边。
3，静态函数。 
    编译时期：参考的是引用型变量所属的类中是否有调用的成员。
    运行时期：也是参考引用型变量所属的类中是否有调用的成员。
    为什么是这样的呢？因为静态方法，其实不所属于对象，而是所属于该方法所在的类。
    调用静态的方法引用是哪个类的引用调用的就是哪个类中的静态方法。</p>

<h2 id="">    简单说：静态函数 --- 编译运行都看 = 左边。</h2>

<p>------java.lang.Object
Object：所有类的直接或者间接父类，Java认为所有的对象都具备一些基本的共性内容，这些内容可以不断的向上抽取，最终就抽取到了一个最顶层的类中的，该类中定义的就是所有对象都具备的功能。</p>

<p>具体方法：
1，boolean equals(Object obj)：用于比较两个对象是否相等，其实内部比较的就是两个对象地址。
而根据对象的属性不同，判断对象是否相同的具体内容也不一样。所以在定义类时，一般都会复写equals方法，建立本类特有的判断对象是否相同的依据。
    public boolean equals(Object obj){
        if(!(obj instanceof Person))
            return false;
        Person p = (Person)obj;
        return this.age == p.age;
    }
2，String toString()：将对象变成字符串；默认返回的格式：类名@哈希值 = getClass().getName() + '@' + Integer.toHexString(hashCode())
    为了对象对应的字符串内容有意义，可以通过复写，建立该类对象自己特有的字符串表现形式。 
    public String toString(){
        return "person : "+age;
    }
3，Class getClass()：获取任意对象运行时的所属字节码文件对象。
4，int hashCode()：返回该对象的哈希码值。支持此方法是为了提高哈希表的性能。</p>

<h2 id="equalstostringhashcode">通常equals，toString，hashCode，在应用中都会被复写，建立具体对象的特有的内容。</h2>

<h2 id="abbaaba">内部类：如果A类需要直接访问B类中的成员，而B类又需要建立A类的对象。这时,为了方便设计和访问，直接将A类定义在B类中。就可以了。A类就称为内部类。内部类可以直接访问外部类中的成员。而外部类想要访问内部类，必须要建立内部类的对象。</h2>

<p>class Outer{
    int num = 4; <br>
    class  Inner {
        void show(){
            System.out.println("inner show run "+num); <br>
        }
    }
    public void method(){
        Inner in = new Inner();//创建内部类的对象。
        in.show();//调用内部类的方法。 
    }</p>

<h2 id="">}</h2>

<p>当内部类定义在外部类中的成员位置上，可以使用一些成员修饰符修饰 private、static。
1：默认修饰符。
直接访问内部类格式：外部类名.内部类名 变量名 =  外部类对象.内部类对象;
Outer.Inner in = new Outer.new Inner();//这种形式很少用。
    但是这种应用不多见，因为内部类之所以定义在内部就是为了封装。想要获取内部类对象通常都通过外部类的方法来获取。这样可以对内部类对象进行控制。
2：私有修饰符。
    通常内部类被封装，都会被私有化，因为封装性不让其他程序直接访问。 
3：静态修饰符。
    如果内部类被静态修饰，相当于外部类，会出现访问局限性，只能访问外部类中的静态成员。
    注意；如果内部类中定义了静态成员，那么该内部类必须是静态的。</p>

<p>内部类编译后的文件名为：“外部类名$内部类名.java”；</p>

<p>为什么内部类可以直接访问外部类中的成员呢？
那是因为内部中都持有一个外部类的引用。这个引用是 外部类名.this 
内部类可以定义在外部类中的成员位置上，也可以定义在外部类中的局部位置上。
当内部类被定义在局部位置上，只能访问局部中被final修饰的局部变量。</p>

<p>匿名内部类：没有名字的内部类。就是内部类的简化形式。一般只用一次就可以用这种形式。匿名内部类其实就是一个匿名子类对象。想要定义匿名内部类：需要前提，内部类必须继承一个类或者实现接口。</p>

<p>匿名内部类的格式：new 父类名&amp;接口名(){ 定义子类成员或者覆盖父类方法 }.方法。</p>

<p>匿名内部类的使用场景：
当函数的参数是接口类型引用时，如果接口中的方法不超过3个。可以通过匿名内部类来完成参数的传递。</p>

<h2 id="">其实就是在创建匿名内部类时，该类中的封装的方法不要过多，最好两个或者两个以内。</h2>

<p>//面试
        //1
        new Object(){
            void show(){
                System.out.println("show run"); <br>
            }
        }.show();
        //2
        Object obj = new Object(){
            void show(){
                System.out.println("show run");
            }
        };
        obj.show();</p>

<pre><code>    1和2的写法正确吗？有区别吗？说出原因。
    写法是正确，1和2都是在通过匿名内部类建立一个Object类的子类对象。
    区别：
    第一个可是编译通过，并运行。
    第二个编译失败，因为匿名内部类是一个子类对象，当用Object的obj引用指向时，就被提升为了
</code></pre>

<h2 id="objectobjectshow">        Object类型，而编译时检查Object类中是否有show方法，所以编译失败。</h2>

<p>class InnerClassDemo6 {
    +（static）class Inner{
        void show(){}
    }
    public void method(){
        this.new Inner().show();//可以
    }
    public static void main(String[] args) {//static不允许this
        This.new Inner().show();//错误，Inner类需要定义成static
    }</p>

<h2 id="">}</h2>

<p>interface Inter{
    void show();
}
class Outer{//通过匿名内部类补足Outer类中的代码。
    public static Inter method(){
        return new Inter(){
            public void show(){}
        };
    }
}
class InnerClassDemo7 {
    public static void main(String[] args) {
        Outer.method().show();
    /*
        Outer.method():意思是：Outer中有一个名称为method的方法，而且这个方法是静态的。
        Outer.method().show():当Outer类调用静态的method方法运算结束后的结果又调用了show方法，意味着：method()方法运算完一个是对象，而且这个对象是Inter类型的。
    */
        function (new Inter(){
            public void show(){}
        }); //匿名内部类作为方法的参数进行传递。
    }
    public static void function(Inter in){
        in.show();
    }
}
包：定义包用package关键字。
1：对类文件进行分类管理。
2：给类文件提供多层名称空间。</p>

<p>如果生成的包不在当前目录下，需要最好执行classpath，将包所在父目录定义到classpath变量中即可。
一般在定义包名时，因为包的出现是为了区分重名的类。所以包名要尽量唯一。怎么保证唯一性呢？可以使用url域名来进行包名称的定义。
package pack;//定义了一个包，名称为pack。 注意：包名的写法规范：所有字母都小写。
//package cn.itcast.pack.demo;</p>

<p>类的全名称是 包名.类名
    编译命令：javac –d 位置（.当前路径） java源文件 （就可以自动生成包）</p>

<p>包是一种封装形式，用于封装类，想要被包以外的程序访问，该类必须public；
类中的成员，如果被包以外访问，也必须public；</p>

<p>包与包之间访问可以使用的权限有两种：
1：public 
2：protected：只能是不同包中的子类可以使用的权限。</p>

<p>总结java中的四种权限：
    范围       public        protected       default     private 
同一个类中       ok                ok              ok          ok
同一包中         ok             ok              ok <br>
子类             ok <br>
不同包中         ok</p>
<!-- content end -->
</div>
<br>
<br>
    <div id="disqus_thread"></div>
	<div class="footer">
		<p>© Copyright 2014 by isnowfy, Designed by isnowfy</p>
	</div>
</div>
<script src="main.js"></script>
<script id="content" type="text/mustache">
    <h1>{{title}}</h1>
    <div class="tag">
    {{date}}
    {{#tags}}
    <a href="/#/tag/{{name}}">#{{name}}</a>
    {{/tags}}
    </div>
</script>
<script id="pagesTemplate" type="text/mustache">
    {{#pages}}
    <li>
        <a href="{{path}}">{{title}}</a>
    </li>
    {{/pages}}
</script>
<script>
$(document).ready(function() {
    $.ajax({
        url: "main.json",
        type: "GET",
        dataType: "json",
        success: function(data) {
            $("#title").html(data.name);
            var pagesTemplate = Hogan.compile($("#pagesTemplate").html());
            var pagesHtml = pagesTemplate.render({"pages": data.pages});
            $("#pages").append(pagesHtml);
            //path
            var path = "test";
            //path end
            var now = 0;
            for (var i = 0; i < data.posts.length; ++i)
                if (path == data.posts[i].path)
                    now = i;
            var post = data.posts[now];
            var tmp = post.tags.split(" ");
            var tags = [];
            for (var i = 0; i < tmp.length; ++i)
                if (tmp[i].length > 0)
                    tags.push({"name": tmp[i]});
            var contentTemplate = Hogan.compile($("#content").html());
            var contentHtml = contentTemplate.render({"title": post.title, "tags": tags, "date": post.date});
            $("#main").prepend(contentHtml);
            if (data.disqus_shortname.length > 0) {
                var disqus_shortname = data.disqus_shortname;
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            }
        }
    });
});
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ["\\(", "\\)"]], processEscapes: true}});
</script>
</body>
</html>
